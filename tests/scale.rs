use eth::header::EthHeader as DEthHeader;
use mmr::{bridge::EthHeader, bytes, hash::H256, hex};
use scale::{Decode, Encode};

const HASHES: [&str; 10] = [
    "34f61bfda344b3fad3c3e38832a91448b3c613b199eb23e5110a635d71c13c65",
    "70d641860d40937920de1eae29530cdc956be830f145128ebb2b496f151c1afb",
    "12e69454d992b9b1e00ea79a7fa1227c889c84d04b7cd47e37938d6f69ece45d",
    "3733bd06905e128d38b9b336207f301133ba1d0a4be8eaaff6810941f0ad3b1a",
    "3d7572be1599b488862a1b35051c3ef081ba334d1686f9957dbc2afd52bd2028",
    "2a04add3ecc3979741afad967dfedf807e07b136e05f9c670a274334d74892cf",
    "c58e247ea35c51586de2ea40ac6daf90eac7ac7b2f5c88bbc7829280db7890f1",
    "2cf0262f0a8b00cad22afa04d70fb0c1dbb2eb4a783beb7c5e27bd89015ff573",
    "05370d06def89f11486c994c459721b4bd023ff8c2347f3187e9f42ef39bddab",
    "c0c8c3f7dc9cdfa87d2433bcd72a744d634524a5ff76e019e44ea450476bac99",
];

const HEADER: &str = "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000056e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b4211dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d493478011bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fad7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f054456e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000881300000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000884a000000000000000000000000000000000000000000000000000000000000000002488000000000000004201d4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3";

/// Hash array for tests
fn ha() -> [[u8; 32]; 10] {
    let mut hashes = [[0; 32]; 10];
    (0..10).for_each(|i| hashes[i] = <[u8; 32] as H256>::from(HASHES[i]));
    hashes
}

fn header() -> EthHeader {
    EthHeader::from_go_ffi(
            "0x0000000000000000000000000000000000000000000000000000000000000000",
            0,
            0,
            "0x0000000000000000000000000000000000000000",
            "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
            "0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",
            "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
            "0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544",
            "0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",
            "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "0",
            "5000",
            "17179869184",
            "0xa00000000000000000000000000000000000000000000000000000000000000000",
            "0x880000000000000042",
            "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3",
        )
}

/// the scale codec of hash is its hex string
#[test]
fn hash() {
    let hashes = ha();
    (0..10).for_each(|i| {
        assert_eq!(hashes[i].encode(), hashes[i]);
    });
}

/// the scale codec of hash array is its concatention
#[test]
fn hash_array() {
    let hashes = ha();
    let encoded = hashes.encode();
    assert_eq!(encoded, hashes.concat());
}

#[test]
fn mmr_proof() {
    let hashes = ha();
    assert_eq!(
        format!("08{}", &hex!(&hashes[0..2].concat())),
        hex!(hashes[0..2].to_vec().encode())
    );
}

#[test]
fn eth_header() {
    assert_eq!(
        EthHeader::default().encode(),
        DEthHeader::default().encode()
    );
    let header = header();
    let encoded = format!("0x{}", hex!(header.encode()));

    assert_eq!(HEADER, encoded);
    assert_eq!(
        header,
        EthHeader::decode(&mut bytes!(encoded.as_str()).as_ref()).unwrap()
    );
}
